没有真正的去做题，所以边界range(n), range(n+1), range(n-1) 可能不正确

# 几个概念
## 状态转移方程
```
f[stage_i] = func_转移(  func_决策(f[stage_j])  )
其中 j 满足条件 xxx
```
### 递推
	Fibonacci：f[n] = f[n-1] + f[n-2]
	f[i] = sum(f[j]) n-2<=j<=n-1
递推里面有状态和状态转移，但是没有决策

## 无后效性
后面的状态不会再影响前面的状态，否则会形成死循环
## 确定边界条件
`f[0] = ?`

# DP三要素
+ 子问题 = 明显的？阶段
	+ 知道子问题的解，可以求最终解
+ 状态：如何描述子问题
	+ 如何划分子问题，如何设计状态。
+ 决策 = 怎么由子问题推导出父问题的解

**解决dp的核心问题，在于精妙的划分子问题/设计状态。**

# DP 经典题型
## 线性
### 最长 非升/非降子序列
【问题描述】

在一个无序的序列a1,a2,a3,a4…an里，找到一个最长的序列满足：ai<=aj<=ak…<=am,且i<j<k…<m.（最长非降子序列）。求这个序列的长度
【问题分析】
设结果f[i] 表示 a_i 结尾的解
问题分析：
a[1] 的 最长序列是自己, 
	f[1] = 1
a[2] 的 最长序列要么是a[1] + a[2]，要么是自己
	f[2] = 1 or f[2] = f[1] + 1
```
f[3] = f[2] + 1 (a3>a2)
	 = f[1] + 1 (a3>a1)
	 =  1
```
`f[i] = max(f[j]) + 1  (a[j]<=a[i] & j<i)`
边界：f[i] = 1

```python
a: list
n = len(a)
f: list = [1] * (n + 1)
for i in range(n):
	for j in range(i):
		if a[j] <= a[i]:
			f[i] = max(f[i], f[j] + 1)
```


## 路径问题
【问题描述】
写一个程序来计算从最高点开始在底部任意处结束的路径经过数字的和的最大。每一步可以走到左下方的点也可以到达右下方的点。

7
3   8
8   1   0
2   7   4   4
4   5   2   6   5
【问题分析】
```python
f[i,j] = max(f[i-1, j], f[i, j-1]) + a[i,j]
f[] = 0
```
直观搜索
```python
f[i+1, j] = max(f[i+1, j], f[i,j] + a[i+1,j])
f[i, j+1] = max(f[i, j+1], f[i,j] + a[i,j+1])

f[0,0] = a[0,0]
```

*回顾三要素*

## 背包
### 01背包
现有N个物品，每个物品的价值为Vi，重量为Wi。求用一个载重量为S的背包装这写物品，使得所装物品的总价值最高。每个物品仅可用一次，要么放要么不放，所以叫01背包。
【状态设计】
```
f[cost] 表示 空间为cost时的最大价值
```
`
```python
for i in range(n):
	for j in range(S, w[i] - 1, -1):
		f[j] = max(f[j], f[j-w[i]] + v[i])
```
### 完全背包
每个物品可以用无数次。
可以转化成01背包，同一个物品用 k 次，作为一个新物品, k的上限由背包载重量决定。
`v = a[i] *k `  `w = w[i] * k`
预处理出所有的物品
```python
for i in range(n):
	for j in range(w[i], S + 1):
		f[j] = max(f[j], f[j-w[i]] + v[i])
```
#### 循环顺序为什么重要
假设有2个物品，背包总量为4
item1:  value = 1  ,  weight = 2
item2:  value = 2,  weight = 2
```
01
item1 f[i]: 0 1 1 1
item2 f[4]: 0 1 1 3
	  f[3]: 0 1 3 3
	  f[2]: 0 2 3 3
```

```
完全 
item1 f[i]: 0 1 1 1
item2 f[2]: 0 2 1 1
	  f[3]: 0 2 2 1
	  f[4]: 0 2 2 4
```
倒序保证的是f[i]更新时，f[0..i-1] 都还没有被当前这件物品更新。
### 背包九讲

背包问题可以理解成是在资源有限的情况下，知道每个决策的消费和收益，求目标收益的问题。
## 区间
###  石子合并
【问题描述】
给定一个序列，每次选择序列中的两个相邻的数字合并。并将合并后的数字作为本次合并的得分。求最大能得多少分。
先不考虑处理环形的问题。
【输入样例】
3
1 2 3
【输出样例】
11
	说明：
		把2 3 合并成 5，得分5。
		此时序列是 1 5
		合并 1 5，            得分6，总得分11
【问题分析】
```python
f[i,j] 表示，以 a_i 开始， a_j 结束的序列的最大得分
sum[i,j] = sum(a[i: j+1])
f[i,j] = max(f[i,k] + f[k+1, j]) + sum[i,j]  (i<=k<j)
f[i,i] = 0
```

```python
a: List[int]
n = len(a)
for l in range(1, n):
	for i in range(n - l):
		j = i + l
		for k in range(i, j):
			f[i][j] = max(f[i][j], f[i][k] + f[k+1][j]) + sum[i][j]
```

区间dp的特点是，一个大块的答案由小块生成。往往需要枚举区间长度，从最小长度的区间开始算起。
## 树形
### 加分二叉树
【问题描述】
设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di。
每棵树及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：
subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数
若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；
（1）tree的最高加分
（2）tree的前序遍历

【输入样例】
5
5 7 1 2 10
【输出样例】
145
3 1 2 4 5
【问题分析】
题目中说这个树的中序遍历是1，2，3……N，我们要求的是树的先序，这样马上就想到怎样用中序和先序确定一棵树。
枚举树根i那么1，2……i-1就是它的左子树中的结点，i+1……N就是它右子树中的结点。
这样一颗树按这样的低归定义就构造出来了，（当然我们只要这个过程并不需要存储这棵树）。在构造过程中顺便求出加分来，在一个序列里不同的元素做根显然加分不同，我们只要记录一个最大的就可以了。

具体实现方法：

设计状态opt[L,r]表示以L为起点，以r为终点的结点所组成的树的最高加分，阶段就是树的层数。决策就是在这些结点中找一个结点做根使树的加分最大，状态转移方程：

```python
1                                   (L>r) 空树
opt[L,r] =  a[L]                    (L=r) 叶子
max{opt[L,i-1] * opt[i+1,r] +a[i]}     (L<r, L<=i<=r)
```


在保存最优解的过程用path[i,j]记录以i为起点，以j为终点的中序结点中的根就可以了。
由于树型动态规划的阶段不明显所以一般用记忆化搜索好实现

```python

def dp(l: int, r: int):
	if opt[l][r]:
		return opt[l][r]
	if l > r:
		opt[l][r] = 1
	elif l == r:
		opt[l][r] = d[l]
	else:
		for k in range(l, r + 1):
			tmp = dp(l, k) * dp(k, r) + d[k]
			if tmp > opt[l][r]:
				opt[l][r] = tmp
				path[l][r] = k
	return opt[l][r]

dp(0, n-1)
```

树形dp的特点在于，把一颗树的问题分割成子树的问题。
一般是做二叉树，因为二叉树的决策只有 左子树 和 右子树。多叉树会转成二叉树。
dp是一种思想和题型，和记忆化搜索没有明显的边界。

# 回头再看怎么做DP题
有明确的阶段划分/子问题。
## 经验 + 直觉
+ 设计状态
+ 状态转移，反例，推翻，重新设计
## 爆搜确定阶段 + 状态 + 状态转移
+ 爆搜确定思路
+ 明确子问题，确定状态
+ 确定状态转移，转移的条件可能很多，剪枝。
+ 手推最初的几个状态，观察状态和状态转移
+ 树形dp，图上的dp，记忆化搜索



dp是需要经验和阅题量的，状态的设计往往有很大的相似性，所以才被划分成各类问题。
1. 大量做dp题，硬背状态转移
2. 尝试不看题解做dp题，做出来。但是这个时候往往已经知道一个题的解法是dp了
3. 看什么题都是dp，开始总结什么样的是dp，什么样的不是

# 优化
+ 状态压缩： 几个状态合并成一个状态
+ 单调队列优化： 加速决策过程，剪掉必不可能的决策
+ 凸包 & 四边形不等式
